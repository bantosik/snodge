package com.natpryce.snodge

import java.nio.charset.Charset
import java.util.Random


/**
 * A Mutagen maps a value to a finite sequence of mutations of that value.
 *
 * Mutations are calculated lazily so that mutants only need be constructed
 * for a random sample of all possible mutations.
 */
typealias Mutagen<T> = (Random, T) -> Sequence<Lazy<T>>

/**
 * Combines multiple Mutagens into a single Mutagen that generates all the mutations of its components.
 *
 * @param mutagens the Mutagens to combine
 * @return the combination Mutagen
 */
fun <T> combine(vararg mutagens: Mutagen<T>): Mutagen<T> {
    return combine(mutagens.toList())
}

/**
 * Combines multiple Mutagens into a single Mutagen that generates all the mutations of its components.
 *
 * @param mutagens the Mutagens to combine
 * @return the combination Mutagen
 */
fun <T> combine(mutagens: Iterable<Mutagen<T>>): Mutagen<T> =
    fun(random: Random, original: T) =
        mutagens.asSequence().flatMap { it(random, original) }


operator fun <T> Mutagen<T>.plus(that: Mutagen<T>) = combine(this, that)


/**
 * Transforms a Mutagen, so that it mutates values of a different type.
 */
fun <T, U> Mutagen<U>.mapped(mapIn: (T) -> U, mapOut: (U) -> T): Mutagen<T> =
    fun(random: Random, original: T) =
        this(random, mapIn(original)).mapLazy(mapOut)

internal fun <T, U> Sequence<Lazy<T>>.mapLazy(f: (T) -> U) = map { lazy { f(it.value) } }


/**
 * Applies the mutation with probability `p`, returning an empty sequence of mutants otherwise.
 */
fun <T> Mutagen<T>.withProbability(p: Double): Mutagen<T> =
    fun(random: Random, original: T) =
        if (random.nextDouble() < p) this(random, original) else emptySequence()

/**
 * Returns a sequence of the mutations generated by `this` and further mutations of those mutations, mutated by `more`.
 */
fun <T> Mutagen<T>.and(more: Mutagen<T>): Mutagen<T> =
    fun(random: Random, original: T) =
        this(random, original).flatMap { sequenceOf(it) + more(random, it.value) }


/**
 * Applies the mutation if the original meets the criteria, returning an empty sequence of mutants otherwise.
 */
fun <T> Mutagen<T>.filtered(criteria: (T) -> Boolean) =
    fun (random: Random, original: T) =
        if (criteria(original)) this(random, original) else emptySequence()
